# Map forge information to rpm metadata. This macro will compute default spec
# variable values.
#
# The following spec variables SHOULD be set before calling the macro:
#
#   forgeurl  the project url on the forge, strongly recommended;
#             alternatively, use -u <url>
#   Version   if applicable, set it with Version: <version>
#   tag       if applicable
#   commit    if applicable
#   date      if applicable (to override the mtime of the Source archive)
#
# The macro will attempt to compute and set the following variables if they are
# not already set by the packager:
#
#   forgesource    an URL that can be used as SourceX: value
#   forgesetupargs the correct arguments to pass to %setup for this source
#                  used by %forgesetup and %forgeautosetup
#   archivename    the source archive filename, without extentions
#   archiveext     the source archive filename extensions, without leading dot
#   archiveurl     the url that can be used to download the source archive,
#                  without renaming
#   scm            the scm type, when packaging code snapshots: commits or tags
#
# If the macro is unable to parse your forgeurl value set at least archivename
# and archiveurl before calling it.
#
# Most of the computed variables are both overridable and optional. However,
# the macro WILL REDEFINE %{dist} when packaging a snapshot (commit or tag).
# The previous %{dist} value will be lost. Don’t call the macro if you don’t
# wish %{dist} to be changed.
#
# Optional parameters:
#   -u <url>  Ignore forgeurl even if it exists and use <url> instead. Note
#             that the macro will still end up setting <url> as the forgeurl
#             spec variable if it manages to parse it.
#   -s  Silently ignore problems in forgeurl, use it if it can be parsed,
#       ignore it otherwise.
#   -p  Restore problem handling, override -s.
#   -v  Be verbose and print every spec variable the macro sets.
#   -i  Print some info about the state of spec variables the macro may use or
#       set at the end of the processing.
%forgemeta(u:spvi) %{lua:
local forgeurl    = rpm.expand("%{?-u*}")
if (forgeurl == "") then
  forgeurl        = rpm.expand("%{?forgeurl}")
end
local silent      = false
local verbose     = false
local informative = false
if (rpm.expand("%{?-s}") ~= "") then
  silent          = true
end
if (rpm.expand("%{?-p}") ~= "") then
  silent          = false
end
if (rpm.expand("%{?-v}") ~= "") then
  verbose         = true
end
if (rpm.expand("%{?-i}") ~= "") then
  informative     = true
end
-- Packaging a moving branch is quite a bad idea, but since at least Gitlab
-- will treat branches and tags the same way better support branches explicitly
-- than have packagers hijack %{tag} to download branch states
local                       tag = rpm.expand("%{?tag}")
local                    commit = rpm.expand("%{?commit}")
local                    branch = rpm.expand("%{?branch}")
local                   version = rpm.expand("%{?version}")
local                       ref = ""
if     (tag     ~= "") then ref = "%{?tag}"
elseif (commit  ~= "") then ref = "%{?commit}"
elseif (branch  ~= "") then ref = "%{?branch}"
else                        ref = "%{?version}"
end
if (rpm.expand(ref) == "") then
  rpm.expand("%{error:You need to define Version:, %{commit} or %{tag} before the macro invocation !}")
end
-- Be explicit about the spec variables we’re setting
local function explicitset(rpmvariable,value)
  rpm.define(rpmvariable .. " " .. value)
  if verbose then
    rpm.expand("%{echo:Setting %%{" .. rpmvariable .. "} = " .. value .. "}")
  end
end
-- Never ever stomp on a spec variable the packager already set
local function safeset(rpmvariable,value)
  if (rpm.expand("%{?" .. rpmvariable .. "}") == "") then
    explicitset(rpmvariable,value)
  end
end
-- Computes the suffix of a version string, removing vprefix if it matches
-- For example with vprefix 1.2.3: 1.2.3.rc2 → .rc2 but 1.2.30 → 1.2.30 not 0
local function getversionsuffix(vstring,vprefix)
  if (string.sub(vstring, 1, #vprefix) == vprefix) and
     (not string.match(string.sub(vstring, #vprefix + 1), "^%.?%d")) then
    return string.sub(vstring, #vprefix + 1)
  else
    return vstring
  end
end
-- Set spec variable values for each known software publishing service
if (forgeurl ~= "") then
  local forge          = string.match(forgeurl, "^[^:]+://([^/]+)/")
  if (forge == nil) then
    if not silent then
      rpm.expand("%{error:URLs must include a protocol such as https:// and a path starting with / !}")
    end
  else
    if (string.match(forge, "^gitlab[%.-]") or string.match(forge, "[%.-]gitlab[%.]")) then
      forgeurl = string.match(forgeurl, "https://[^/]+/[^/]+/[^/#?]+")
      if (forgeurl == nil) then
        if not silent then
          rpm.expand("%{error:Gitlab URLs must match https://(…[-.])gitlab[-.]…/owner/repo !}")
        end
      else
        explicitset("forgeurl",   forgeurl)
        safeset("archiveext",     "tar.bz2")
        safeset("forgesetupargs", "-n %{archivename}")
        if (ref ~= "%{?version}") then safeset("scm", "git") end
        local repo  = string.match(forgeurl, "^[^:]+://[^/]+/[^/]+/([^/]+)")
        safeset("archivename", repo .. "-" .. ref)
        safeset("archiveurl",  "%{forgeurl}/-/archive/" .. ref .. "/%{archivename}.%{archiveext}")
      end
    end
    if (string.match(forge, "^github[%.-]") or string.match(forge, "[%.-]github[%.]")) then
      forgeurl = string.match(forgeurl, "https://[^/]+/[^/]+/[^/#?]+")
      if (forgeurl == nil) then
        if not silent then
          rpm.expand("%{error:GitHub URLs must match https://(…[-.])github[-.]…/owner/repo !}")
        end
      else
        explicitset("forgeurl",   forgeurl)
        safeset("archiveext",     "tar.gz")
        safeset("forgesetupargs", "-n %{archivename}")
        -- Workaround the way GitHub injects "v"s before some version strings (but not all!)
        -- To package one of the minority of sane GitHub projects that do not munge their version
        -- strings set tag to %{version} in your spec
        local fileref = ref
        if (ref == "%{?version}") then
          ref = "v" .. ref
        else
          safeset("scm", "git")
          if (fileref ~= "%{?commit}") and string.match(rpm.expand(fileref), "^v[%d]") then
            fileref = string.gsub(rpm.expand(fileref), "^v", "")
          end
        end
        local repo = string.match(forgeurl, "^[^:]+://[^/]+/[^/]+/([^/]+)")
        safeset("archivename", repo .. "-" .. fileref)
        safeset("archiveurl",  "%{forgeurl}/archive/" .. ref .. "/%{archivename}.%{archiveext}")
      end
    end
    if (forge == "code.googlesource.com") then
      forgeurl = string.match(forgeurl, "https://code.googlesource.com/[^#?]*[^/#?]+")
      if (forgeurl == nil) then
        if not silent then
          rpm.expand("%{error:Googlesource URLs must match https://code.googlesource.com/…/repo !}")
        end
      else
        explicitset("forgeurl",   forgeurl)
        safeset("archiveext",     "tar.gz")
        safeset("forgesetupargs", "-c")
        if (ref == "%{?version}") then
          ref = "v" .. ref
        else
          safeset("scm", "git")
        end
        local repo = string.match(forgeurl, "^[^:]+://.+/([^/?#]+)")
        safeset("archivename", repo .. "-" .. ref)
        safeset("archiveurl",  "%{forgeurl}/+archive/" .. ref .. ".%{archiveext}")
      end
    end
    if (forge == "bitbucket.org") then
      forgeurl = string.match(forgeurl, "https://[^/]+/[^/]+/[^/#?]+")
      if (forgeurl == nil) then
        if not silent then
          rpm.expand("%{error:BitBucket URLs must match https://bitbucket.org/owner/repo !}")
        end
      else
        explicitset("forgeurl",   forgeurl)
        if (commit == "") then
          rpm.expand("%{error:All BitBucket URLs require commit value knowledge: you need to define %{commit}!}")
        end
        local shortcommit = string.sub(commit, 1, 12)
        safeset("archiveext", "tar.bz2")
        -- Default to git even though BitBucket allows choosing between several SCMs
        -- Set scm to hg for example before calling the macro if your project does not use git
        safeset("scm", "git")
        local owner = string.match(forgeurl, "^[^:]+://[^/]+/([^/]+)")
        local repo  = string.match(forgeurl, "^[^:]+://[^/]+/[^/]+/([^/]+)")
        safeset("archivename",    owner .. "-" .. repo .. "-" .. shortcommit)
        safeset("forgesetupargs", "-n %{archivename}")
        if (tag ~= "") then
          safeset("archiveurl",  "%{forgeurl}/get/%{tag}.%{archiveext}")
        else
          safeset("archiveurl",  "%{forgeurl}/get/%{commit}.%{archiveext}")
        end
      end
    end
    if (forge == "pagure.io") then
      if not silent then
        rpm.expand("%{error:https://pagure.io/pagure/issue/861 needs to be resolved before the “pagure.io”\\nsoftware publishing service can be supported.}")
      end
    end
    -- Final tests to check forgeurl was successfuly parsed
    if not silent then
      if (rpm.expand("%{?archivename}") == "") or (rpm.expand("%{?archiveurl}") == "") then
        rpm.expand("%{error:Automation for the “" .. forge .. "”\\nsoftware publishing service is not implemented yet.\\nPlease extend the %%forgemeta macro!}")
      end
    end
  end
end
-- Set defaults if forgeurl is missing or does not parse
local archivename = rpm.expand("%{?archivename}")
safeset("archiveext",       "tar.gz")
if (archivename ~= "") then
  safeset("forgesetupargs", "-n %{archivename}")
end
if (commit ~= "") or (tag ~= "") then
  safeset("scm",            "git")
end
-- Source URL processing (computing the forgesource spec variable)
local archiveurl  = rpm.expand("%{?archiveurl}")
local archiveext  = rpm.expand("%{?archiveext}")
if (archivename ~= "") and (archiveurl ~= "") then
  if (string.match(archiveurl, "/([^/]+)$") == archivename .. "." .. archiveext) then
    safeset("forgesource", "%{archiveurl}")
  else
    safeset("forgesource", "%{?archiveurl}#/%{?archivename}.%{archiveext}")
  end
end
-- dist processing (computing the correct prefix for snapshots)
local distprefix = rpm.expand(ref)
if     (ref == "%{?commit}") then
  distprefix = string.sub(distprefix, 1, 7)
elseif (ref ~= "%{?branch}") then
  distprefix = getversionsuffix(distprefix,        version)
  distprefix = getversionsuffix(distprefix, "v" .. version)
  distprefix = string.gsub(distprefix, "[.-]+", ".")
  distprefix = string.gsub(distprefix, "^%.", "")
end
if (distprefix ~= "") then
  distprefix = "%{scm}" .. distprefix
  date = rpm.expand("%{?date}")
  if (date ~= "") then
    distprefix = date .. distprefix
  else
    distprefix = "%([ -r %{_sourcedir}/%{archivename}.%{archiveext} ] && date +%Y%m%d -u -r %{_sourcedir}/%{archivename}.%{archiveext})" .. distprefix
  end
  safeset ("distprefix", "." .. distprefix)
end
-- Final spec variable summary if the macro was called with -i
if informative then
  rpm.expand("%{echo:Forge-specific packaging variables}")
  rpm.expand("%{echo:  forgeurl:        %{?forgeurl}}")
  rpm.expand("%{echo:  forgesource:     %{?forgesource}}")
  rpm.expand("%{echo:  forgesetupargs:  %{?forgesetupargs}}")
  rpm.expand("%{echo:Generic packaging variables}")
  rpm.expand("%{echo:  archivename:     %{?archivename}}")
  rpm.expand("%{echo:  archiveext:      %{?archiveext}}")
  rpm.expand("%{echo:  archiveurl:      %{?archiveurl}}")
  rpm.expand("%{echo:  scm:             %{?scm}}")
  rpm.expand("%{echo:  tag:             %{?tag}}")
  rpm.expand("%{echo:  commit:          %{?commit}}")
  rpm.expand("%{echo:  branch:          %{?branch}}")
  rpm.expand("%{echo:  date:            %{?date}}")
  rpm.expand("%{echo:  distprefix:      %{?distprefix} (snapshot date is either manually supplied or computed once %%{_sourcedir}/%%{archivename}.%%{archiveext} is available)}")
end
}

# Convenience macro to relay computed arguments to %setup
%forgesetup(a:b:cDn:Tq) %setup %{?forgesetupargs} %{-a} %{-b} %{-c} %{-D} %{-n} %{-T} %{-q}

# Convenience macro to relay computed arguments to %autosetup
%forgeautosetup(a:b:cDn:TvNS:p:) %autosetup %{?forgesetupargs} %{-a} %{-b} %{-c} %{-D} %{-n} %{-T} %{-v} %{-N} %{-S} %{-p}
